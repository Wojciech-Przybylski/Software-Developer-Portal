# Authentication and Permissions

This page documents steps to setup and integrate organisation authentications and permissions.

## Authentication

### GitHub Apps

Backstage can be configured to use GitHub Apps for backend authentication. This comes with advantages such as higher rate limits and that Backstage can act as an application instead of a user or bot account.

It also provides a much clearer and better authorisation model as a opposed to the OAuth apps and their respective scopes.

### Caveats

- This authentication method is designed for authenticating towards organization repositories, not personal repositories.

- It is not possible to have multiple Backstage GitHub Apps installed in the same GitHub organization to be managed by Backstage. Currently, the SDP does not check through all the registered GitHub Apps to determine which ones are installed for a particular repository. Only global organization installs are respected at this time.

- The created GitHub App is private by default, which is generally preferred for github.com.

### Setup

A GitHub App created with the CLI will have read access by default. Additional permissions must be manually updated in the GitHub App settings on GitHub if needed.

To integrate a GitHub App you can create it using these [instructions](https://backstage.io/docs/integrations/github/github-apps). Which will automatically link it to your backstage instance.

Once the application is created it will generate a YAML file with a `privateKey` as shown below, the YAML file will be named after your GitHub app e.g `backstage-app-credentials.yaml`.

```yml
appId: app id
clientId: client id
clientSecret: client secret
webhookSecret: webhook secret
privateKey: |
  -----BEGIN RSA PRIVATE KEY-----
  ...Key content...
  -----END RSA PRIVATE KEY-----
```

### Permissions

### Repository permissions

![repository-permissions](./assets/github-app-repository-permissions.png)

### Organisation permissions

![organisation-permissions](./assets/github-app-organisation-permissions.png)

### Including in Integrations Config​
Once the credentials are stored in a YAML file generated by create-github-app, they can be included in the app-config.yaml under the integrations section.

Please note that the credentials file is highly sensitive and should NOT be checked into any kind of version control. Instead use your preferred secure method of distributing secrets.

```yml
integrations:
  github:
    - host: github.com
      apps:
        - $include: example-backstage-app-credentials.yaml
```

### Local configuration
During local development, the SDP team has been utilising the 'backstage-dummy-org' GitHub Organization. This setup has provided a non-restricted, sandbox environment that allows for testing of functionality, template features, and GitHub integrations.

To switch to a different configuration, modifications to app-config.yaml and catalog.ts files will be necessary, particularly in the following areas:

```yml
#app-config.yaml
catalog:
  providers:
    github:
      providerId:
        organization: '${BSTAGE_GITHUB_ORGANISATION}' - # make sure that the env variable is changed to org you want to use 
```

```yml
#app-config.yaml
integrations:
  github:
    - host: github.com
      apps:
        - $include: 'example-backstage-app-credentials.yaml' - # make sure that the correct file is referenced here which is linked to the organisation you want to use
```
```ts
//catalog.ts 
 const githubOrgEntityProvider = GithubOrgEntityProvider.fromConfig(env.config, {
    id: 'production',
    orgUrl: 'https://github.com/backstage-dummy-org', - // make the changes here as well to match the organisation you will be using.
    ...
```


## Permissions

The permissions framework depends on a few other Backstage systems, which must be set up before we can dive into writing a policy.

### Upgrade to the latest version of Backstage​
The permissions framework itself is new to Backstage and still evolving quickly. To ensure your version of Backstage has all the latest permission-related functionality, it’s important to upgrade to the latest version. The [Backstage upgrade helper](https://backstage.github.io/upgrade-helper/) is a great tool to help ensure that you’ve made all the necessary changes during the upgrade!

### Enable service-to-service authentication​
Service-to-service authentication allows Backstage backend code to verify that a given request originates from elsewhere in the Backstage backend. This is useful for tasks like collation of catalog entities in the search index. This type of request shouldn’t be permissioned, so it’s important to configure this feature before trying to use the permissions framework.

To set up service-to-service authentication, follow the [service-to-service authentication docs](https://backstage.io/docs/auth/service-to-service-auth).

## Integrating permission framework with your Backstage instance​

<br/>

### 1. Set up the permission backend​

The permissions framework uses a permission-backend plugin to accept authorization requests from other plugins across your Backstage instance. The Backstage backend does not include this permission backend by default, so you will need to add it:

1. Add @backstage/plugin-permission-backend as a dependency of your Backstage backend:

        # From your Backstage root directory
        yarn add --cwd packages/backend @backstage/plugin-permission-backend

2. Add the following to a new file, packages/backend/src/plugins/permission.ts. This adds the permission-backend router, and configures it with a very basic policy which restricts catalog entity read permission.

```ts
import {
  BackstageIdentityResponse,
  IdentityClient
} from '@backstage/plugin-auth-node';
import { createRouter } from '@backstage/plugin-permission-backend';
import {
  AuthorizeResult,
  PolicyDecision,
  isPermission,
} from '@backstage/plugin-permission-common';
import {
  PermissionPolicy,
  PolicyQuery,
} from '@backstage/plugin-permission-node';import { Router } from 'express';
import { PluginEnvironment } from '../types';
import {
  catalogConditions,
  createCatalogConditionalDecision,
} from '@backstage/plugin-catalog-backend/alpha';
import {
  catalogEntityReadPermission,
} from '@backstage/plugin-catalog-common/alpha';

class TestPermissionPolicy implements PermissionPolicy {
  async handle(
    request: PolicyQuery,
    user?: BackstageIdentityResponse,
  ): Promise<PolicyDecision> {
    if (isPermission(request.permission, catalogEntityReadPermission)) {
      return createCatalogConditionalDecision(
        request.permission,
        catalogConditions.isEntityOwner({
          claims: user?.identity.ownershipEntityRefs ?? [],
        }),
      );
    }

    return { result: AuthorizeResult.ALLOW };
  }
}

export default async function createPlugin(
  env: PluginEnvironment,
): Promise<Router> {
  return await createRouter({
    config: env.config,
    logger: env.logger,
    discovery: env.discovery,
    policy: new TestPermissionPolicy(),
    identity: env.identity,
  });
}
```

3. Wire up the permission policy in packages/backend/src/index.ts. The index in the example backend shows how to do this. You’ll need to import the module from the previous step, create a plugin environment, and add the router to the express app:
```ts
import permission from './plugins/permission';


const permissionEnv = useHotMemoize(module, () => createEnv('permission'));


apiRouter.use('/permission', await permission(permissionEnv));
```
### 2. Enable and test the permissions system​

Now that the permission backend is running, it’s time to enable the permissions framework and make sure it’s working properly.

1. Set the property permission.enabled to true in app-config.yaml. 

```yml
permission:
  enabled: true
```

### 3. Custom permissions

You can also customize the permissions and create your own custom permissions dependant on the application's requirements.

Here's a set of custom permissions with basic read functionality which is currently being used by the SDP to restrict access to the whole application and only grant access to the tech radar dependant on which github org group you are part of. 

```ts
#customPermissions.ts

import { ResourcePermission, createPermission } from "@backstage/plugin-permission-common";
//Permission Definitions
/**
 * Represents a resource permission for accessing the tech radar catalog entity.
 */
export const fullAccess: ResourcePermission<"catalog-entity"> = createPermission({
  /**
   * The name of the permission.
   */
  name: "catalog.entity.fullAccess",
  /**
   * The attributes of the permission.
   */
  attributes: {
    /**
     * The action allowed by the permission.
     */
    action: "read",
  },
  /**
   * The type of the resource associated with the permission.
   */
  resourceType: "catalog-entity",
});

export const techRadarAccess: ResourcePermission<"catalog-entity"> = createPermission({
  name: "catalog.entity.techRadarAccess",
  attributes: {
    action: "read",
  },
  resourceType: "catalog-entity",
});

export const customPermissions = [
    fullAccess,
    techRadarAccess
];


```

Here is how the fullAccess permissions is later used in the permission.ts

```ts
  // Full Access
  if (isPermission(request.permission, fullAccess)) {
    if (isPartOfGroup(['admin', 'dev-team'])) {
      console.log('Allowed full access');
      return { result: AuthorizeResult.ALLOW };
    } else {
      console.log('Denied full access');
      return { result: AuthorizeResult.DENY };
    }
  }

```


The permissions are also being declared in packages/app/src/App.tsx to check which permissions are being authenticated thus granting access to specific part of the application.

like so: 
```ts
function CheckPermission(_props:any) {
    
  const { loading: loadingPermission, allowed: readAllowed } = usePermission({permission: fullAccess, resourceRef: 'packages/backend/src/plugins/permission.ts',});
  
  let displayContent = <><AppRouter><Root>{routes}</Root></AppRouter></>;
  
  
  if (!loadingPermission && !readAllowed) {
       displayContent = <>
       <AppRouter><Root><WarningPanel severity= 'info' title= "Limited Access" message= 'You are not authorised to have full access to the platform. For further questions and queries about the software developer portal access contact: ............'/>{tech_radar}</Root></AppRouter></>;

  }
  return displayContent;
}
```

And in packages/app/src/components/Root/Root.tsx to restrict the navigation routes and buttons dependant on your application access permissions

like so:
```ts
export const Root = ({ children }: PropsWithChildren<{}>) => {
  const { allowed: readAllowed } = usePermission({
    permission: fullAccess,
    resourceRef: 'packages/backend/src/plugins/permission.ts',
  });

  const { allowed: readAllowed2 } = usePermission({
    permission: techRadarAccess, 
    resourceRef: 'packages/backend/src/plugins/permission.ts',
  });

  const globalRoutes = [
    <SidebarItem key="home" icon={HomeIcon} to="/" text="Home" />,
    <SidebarItem key="catalog" icon={CatalogIcon} to="catalog" text="Catalog" />,
    <SidebarItem key="api-docs" icon={ExtensionIcon} to="api-docs" text="APIs" />,
    <SidebarItem key="docs" icon={LibraryBooks} to="docs" text="Docs" />,
    <SidebarItem key="create" icon={CreateComponentIcon} to="create" text="Create..." />,
    <SidebarItem key="announcements" icon={AnnouncmentIcon} to="announcements" text="Announcements" />,
    <SidebarItem key="onboarding" icon={OnboardingIcon} to="onboarding" text="Onboarding" />,
  ];

  const techRoutes = [
    <SidebarItem key="tech-radar" icon={MapIcon} to="tech-radar" text="Tech Radar" />,
    // Add more tech-related routes here
  ];

  let sidebarContent;

  if (readAllowed) {
    sidebarContent = (
      <SidebarPage>
        <Sidebar>
          <SidebarLogo />
          <SidebarGroup label="Search" icon={<SearchIcon />} to="/search">
            <SidebarSearchModal />
          </SidebarGroup>
          <SidebarDivider />
          <SidebarGroup label="Menu" icon={<MenuIcon />}>
            {globalRoutes}
          <SidebarDivider />
            <SidebarScrollWrapper>{techRoutes}</SidebarScrollWrapper>
          </SidebarGroup>
          <SidebarSpace />
          <SidebarDivider />
          <SidebarGroup
            label="Settings"
            icon={<UserSettingsSignInAvatar />}
            to="/settings"
          >
            <SidebarSettings />
          </SidebarGroup>
        </Sidebar>
        {children}
      </SidebarPage>
    ) 
  } else if (readAllowed2) {
    sidebarContent = (
      <SidebarPage>
        <Sidebar>
          <SidebarLogo />
          <SidebarDivider />
          <SidebarGroup label="Menu" icon={<MenuIcon />}>
            <SidebarDivider />
            <SidebarItem key="home" icon={HomeIcon} to="/" text="Home" />
            <SidebarScrollWrapper>{techRoutes}</SidebarScrollWrapper>
          </SidebarGroup>
          <SidebarSpace />
          <SidebarDivider />
          <SidebarGroup
            label="Settings"
            icon={<UserSettingsSignInAvatar />}
            to="/settings"
          >
            <SidebarSettings />
          </SidebarGroup>
        </Sidebar>
        {children}
      </SidebarPage>
    ) 
  } else {
    sidebarContent = (
      <WarningPanel severity='warning' title="Unauthorised Access" message='You are not authorised to have access to the this platform. For further questions and queries about the software developer portal access contact: ............' />
    );
  }

  return sidebarContent;
}

```